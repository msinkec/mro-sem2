
\documentclass[11pt,a4paper,slovene]{myarticle}

%Uporabljeni paketi
\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{caption}
\captionsetup{font={default,footnotesize}, labelfont=bf, format=hang,indention=.0cm}
\usepackage{graphicx,epsfig}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{color}
\usepackage{url}
\usepackage{makeidx}
\usepackage{listings}
\usepackage[official]{eurosym}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\usepackage{hyperref}
\hypersetup{
   bookmarksnumbered=true,
   urlbordercolor={0 1 0},
   linkbordercolor={1 1 1},
   unicode=true,
   pdftitle={ Modeliranje Računalniških Omrežij },
   pdfauthor={Asistent},
   pdfdisplaydoctitle=true,
   pdftoolbar=true,
   pdfmenubar=true,
   pdfstartview=X Y Z
}

\urlstyle{same}

\setlength{\parskip}{12pt}
\setlength\parindent{0pt}
\setlength\unitlength{1mm}

\begin{document}
\label{naslov}
\pdfbookmark[1]{Naslov}{naslov}
\thispagestyle{empty}

\begin{center}
\begin{Large}
Modeliranje računalniških omrežij\\
Študijsko leto 2019/2020\\
\end{Large}

\vspace*{4cm}
\begin{LARGE}
\textbf{Naloga 4 - Modeliranje IPv6 omrežij\\}
\end{LARGE}
\vspace*{0.5cm}

\begin{Large}
Poročilo za drugo seminarsko nalogo\\

\vspace*{4cm}

Mihael Šinkec\\
Vpisna št. 63170277\\
Matej Fortuna\\
Vpisna št. 63170091\\
Matej Fajdiga\\
Vpisna št. 63170084\\
Dominik Skapin\\
Vpisna št. 63150262\\

\vspace*{5cm}
Ljubljana, \today
\end{Large}
\end{center}

\pagebreak
\setcounter{page}{1}
\pagenumbering{arabic}


\label{Kazalo}
\pdfbookmark[1]{Kazalo}{Kazalo}
\tableofcontents
\thispagestyle{empty}
\pagebreak

\section{Opis primerov IPv6 omrežij}
\subsection{Omrežje 1}


\section{Implementacija modulov}
Kot source sem vzel modul iz paketa "queuinglib". Nastavil sem mu parameter za porazdelitev za ustvarjanje zahtev, ter za dodelitev prioritet le tem:

\begin{lstlisting}
Seminarska1.source.interArrivalTime = truncnormal(${m0=0.1..0.8 step 0.1}s, 0.5*${m0}s)
Seminarska1.source.jobPriority = intuniform(1, 10)
\end{lstlisting}


Za switch 1 sem kot podlago vzel datoteke Switch.* iz "dyna" paketa, ki sem jih nato obdelal. Prvo sem ustvaril parameter za izbiro načina posredovanja paketov:

\begin{lstlisting}
Seminarska1.firstSwitch.scheduling = 1
\end{lstlisting}

Vrednost 0 pomeni naključno posredovanje, 1 pa posredovanje enoti, ki ima najmanj zahtev v čakalni vrsti.
Nato sem posodobil implementacijo metode za posredovanje. Dodal sem odsek za izbiro izhoda:

\begin{lstlisting}
 // send msg to destination
int dest = 0;
int outs = 3;
if (scheduling == 0) {
    // choose random queue
    dest = rand() % outs;
} else if (scheduling == 1){
    // choose the queue with the least pending jobs
    int max = 0;
    for (int i = 0; i < outs; i++) {
        queueing::Queue* recv = (queueing::Queue*) (this->gate("out", i)->getNextGate()->getOwner());
        int len = recv->length();
        if (len < max) {
            dest = i;
        } else {
            max = len;
        }
    }
} else {
    throw cRuntimeError("Invalid value for scheduling algorithm.\n");
}

send(msg, "out", dest);
\end{lstlisting}


Kot M/M/1 sistem sem vrel modul iz paketa "queuinglib".

Za switch 2 sem prav tako kot podlago vzel implementacijo switcha iz "dyna" paketa, a mi tokrat ni bilo treba spreminjati kode. Spremenil sem le NED datoteko, da bo modul lahko prejemal pakete iz različnih vhodnih vrat.

Za M/M/c modul sem vzel datoteke, ki sem jih ustvaril za drugo domačo nalogo. Ta je imel FIFO čakalno vrsto, zato sem moral napisati funkcijo za primerjavo zahtev glede na njihovo prioriteto:

\begin{lstlisting}
static int compareMessages(cMessage* a, cMessage* b) {
    cMessage* job1 = check_and_cast<cMessage *>(a);
    cMessage* job2 = check_and_cast<cMessage *>(b);
    int priority1 = job1->getSchedulingPriority();
    int priority2 = job2->getSchedulingPriority();
    if(priority1 < priority2){
        return 1;
    }
    else if (priority1 == priority2){
        return 0;
    }else{
        return -1;
    }
}
\end{lstlisting}

Čakalni vrste sem potem dodelil to funkcijo:

\begin{lstlisting}
CompareFunc compFunc = (CompareFunc) compareMessages;
queue.setup(compFunc);
\end{lstlisting}

Modulu sem tudi dodal signale za zajemanje časa, ki ga je posamezna zahteva preživela v čakalni vrsti tega modula.


\section{Simulacije in rezultati}
Naloga je zahtevala, da izmerim povprečen čas prebivanja zahteve v čakalni vrsti M/M/c modula, glede na prioriteto.

Konfiguracija simulacije:

\begin{lstlisting}
[Config config1]
description = "Konfiguracija 1"
Seminarska1.source.interArrivalTime = truncnormal(${m0=0.1..0.8 step 0.1}s, 0.5*${m0}s)

Seminarska1.source.jobPriority = intuniform(1, 10)

Seminarska1.firstSwitch.scheduling = 1
Seminarska1.firstSwitch.pkRate = 100
Seminarska1.firstSwitch.queueMaxLen = 2000

Seminarska1.queue.serviceTime = 0.8s
Seminarska1.queue1.serviceTime = 0.8s
Seminarska1.queue2.serviceTime = 0.8s

Seminarska1.secondSwitch.pkRate = 100
Seminarska1.secondSwitch.queueMaxLen = 2000

Seminarska1.cPriorityQueue.serviceTime = truncnormal(${m1=1..2 step 0.1}s, 0.5*${m1}s)
Seminarska1.cPriorityQueue.c = 3

**.scalar-recording = true
**.vector-recording = true
\end{lstlisting}

V tej simulaciji so M/M/1 strežne enote imele neomejeno čakalno vrsto, medtem ko je M/M/c imela ČV dolžine 100 zahtev.

M/M/c sem nastavil, da bo imela 3 strežnike.

Simulacijo sem ustavil po generiranju 100000. zahteve.
Rezultate simulacije sem dobil v obliki dveh vektorjev enake dolžine; v prvem so bila števila prioritet n-te zahteve, v drugem pa čas prebivanja v ČV n-te zahteve.

Rezultate sem nato zdrižil s pomočjo Pythona.

\begin{figure}[h]
  \includegraphics[width=\linewidth]{res.png}
\end{figure}

Kot je razvidno na sliki, izstopajo predvsem zahteve z prioriteto 1.

Če povečamo število strežnikov (c), se čas čakanja drastično zniža:
\begin{figure}[h]
  \includegraphics[width=\linewidth]{res2.png}
\end{figure}


\end{document}











